<!-- same styles + markup as before; omitted here for brevity -->
<!-- ... header/buttons/body/dock elements exactly as in the previous snippet ... -->

<script>
(function () {
  // --- grab elements (same as before) ---
  const overlay  = document.getElementById('iw-overlay');
  const backdrop = document.getElementById('iw-backdrop');
  const win      = document.getElementById('iw-window');
  const head     = document.getElementById('iw-header');
  const imgEl    = document.getElementById('iw-img');
  const btnMin   = document.getElementById('iw-min');
  const btnMax   = document.getElementById('iw-max');
  const btnClose = document.getElementById('iw-close');
  const dock     = document.getElementById('iw-dock');

  let state = { visible:false, maximized:false, dragging:false, offsetX:0, offsetY:0, lastLeft:0, lastTop:0, lastW:0, lastH:0, src:'', title:'' };

  // ---- utility fns (same as before) ----
  function showWin(){ backdrop.style.display='block'; win.style.display='block'; state.visible=true; if(!state.maximized) centerWin(); }
  function hideWin(){ backdrop.style.display='none'; win.style.display='none'; state.visible=false; }
  function centerWin(){ const r=win.getBoundingClientRect(); win.style.left=`calc(50% - ${r.width/2}px)`; win.style.top=`calc(50% - ${r.height/2}px)`; win.style.transform='translate(0,0)'; }
  function setImg(src,title='Image Viewer'){ imgEl.src=src; imgEl.alt=title||'image'; state.src=src; state.title=title; }
  function maximize(){ if(state.maximized) return; const r=win.getBoundingClientRect(); state.lastLeft=r.left; state.lastTop=r.top; state.lastW=r.width; state.lastH=r.height; win.style.left='0px'; win.style.top='0px'; win.style.width='100vw'; win.style.height='100vh'; win.style.borderRadius='0'; state.maximized=true; }
  function restore(){ if(!state.maximized) return; win.style.width=state.lastW+'px'; win.style.height=state.lastH+'px'; win.style.left=state.lastLeft+'px'; win.style.top=state.lastTop+'px'; win.style.borderRadius='12px'; state.maximized=false; }
  function minimize(){ const id='dock-'+btoa(state.src).replace(/=+$/,''); let item=document.getElementById(id); if(!item){ item=document.createElement('button'); item.id=id; item.className='iw-dock-item'; const t=document.createElement('img'); t.className='iw-dock-thumb'; t.src=state.src; const l=document.createElement('span'); l.textContent='Image'; item.appendChild(t); item.appendChild(l); item.addEventListener('click',()=>{ setImg(state.src); showWin(); }); dock.appendChild(item); } dock.classList.remove('iw-hidden'); hideWin(); }

  // events
  head.addEventListener('mousedown',e=>{ if(state.maximized) return; state.dragging=true; const r=win.getBoundingClientRect(); state.offsetX=e.clientX-r.left; state.offsetY=e.clientY-r.top; document.body.style.userSelect='none'; });
  window.addEventListener('mousemove',e=>{ if(!state.dragging) return; win.style.left=(e.clientX-state.offsetX)+'px'; win.style.top=(e.clientY-state.offsetY)+'px'; });
  window.addEventListener('mouseup',()=>{ if(state.dragging){ state.dragging=false; document.body.style.userSelect=''; } });
  btnClose.addEventListener('click',hideWin);
  btnMax.addEventListener('click',()=> state.maximized ? restore() : maximize());
  btnMin.addEventListener('click',minimize);
  backdrop.addEventListener('click',hideWin);
  window.addEventListener('keydown',e=>{ if(e.key==='Escape' && state.visible) hideWin(); });

  // only bind to post + feature areas, not the ML embed
  const ROOT_SELECTORS = [
    /* post body content (Congo/Hugo common) */
    'article .prose',             // typical congo post body
    '.single .content',           // alternate content wrapper
    '.post-content',              // custom wrapper if present
    /* feature/cover areas */
    '.post-feature', '.feature-image', '.cover', '.hero-image'
  ];

  // Helper: is the image inside the ML embed wrapper?
  const isInsideMlEmbed = (el) => !!el.closest('[data-ml-embed]');

  function shouldBind(img) {
    if (isInsideMlEmbed(img)) return false;     // hard skip embeds
    const w = img.naturalWidth || img.width || 0;
    const h = img.naturalHeight || img.height || 0;
    return (w >= 80 || h >= 80);
  }

  function installHandlers(root) {
    ROOT_SELECTORS.forEach(sel => {
      root.querySelectorAll(sel + ' img').forEach(img => {
        if (img.dataset.iwBound === '1') return;
        if (!shouldBind(img)) return;
        img.dataset.iwBound = '1';
        img.style.cursor = 'zoom-in';
        img.addEventListener('click', (e) => {
          e.preventDefault();
          setImg(img.currentSrc || img.src, img.alt || 'Image');
          win.style.width = Math.min(window.innerWidth * 0.9, 1000) + 'px';
          win.style.height = Math.min(window.innerHeight * 0.8, 720) + 'px';
          win.style.borderRadius = '12px';
          state.maximized = false;
          showWin();
        });
      });
    });
  }

  const main = document.querySelector('main') || document.body;
  installHandlers(main);

  // If your theme swaps content dynamically, keep binding new nodes:
  const mo = new MutationObserver((muts) => {
    muts.forEach(m => m.addedNodes.forEach(n => { if (n.nodeType === 1) installHandlers(n); }));
  });
  mo.observe(main, { childList: true, subtree: true });
})();
</script>
